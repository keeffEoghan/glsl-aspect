{"version":3,"sources":["../node_modules/@epok.tech/gl-screen-triangle/index.js","../node_modules/@epok.tech/gl-screen-triangle/uv-ndc.vert.glsl","index.frag.glsl","index.js"],"names":["positions","vertices","count","length","dim","flat","module","exports","regl","img","Image","image","texture","addEventListener","data","flipY","src","imageSrc","draw","vert","frag","attributes","position","uniforms","imageWidth","width","imageHeight","height","viewWidth","context","viewHeight","mode","prop","scale","modes","state","clear","color","depth","frame","document","x","clientX","Math","max","innerWidth","console","log"],"mappings":";;;;;AAsBeA,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,QAAAA,QAAAA,UAAAA,QAAAA,IAAAA,QAAAA,MAAAA,QAAAA,cAAAA,EAhBR,IAAMC,EAAW,CAAC,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,IAgBlCD,QAAAA,SAAAA,EAdR,IAAME,EAAQD,EAASE,OAcfH,QAAAA,MAAAA,EAbR,IAAMI,EAAM,EAaJJ,QAAAA,IAAAA,EAFR,IAAMA,EAAYC,EAASI,OAEnBL,QAAAA,UAAAA,EAAAA,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;;;ACtBfM,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;ACsDf,aArDA,IAAA,EAAA,EAAA,QAAA,SACA,EAAA,QAAA,iCAEA,EAAA,EAAA,QAAA,wBAEA,EAAA,EAAA,QAAA,mDAEA,EAAA,EAAA,QAAA,sBA8CA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA5CA,IAAMC,GAAO,EAAb,EAAA,WAEMC,EAAM,IAAIC,MACVC,EAAQH,EAAKI,UAEnBH,EAAII,iBAAiB,OAAQ,WAAMF,OAAAA,EAAM,CAAEG,KAAML,EAAKM,OAAO,MAC7DN,EAAIO,IAAMC,EAAV,QAEA,IAAMC,EAAOV,EAAK,CACdW,KAAAA,EADc,QAEdC,KAAAA,EAFc,QAGdC,WAAY,CAAEC,SAAUtB,EAAAA,WACxBuB,SAAU,CACNZ,MAAAA,EACAa,WAAY,WAAMb,OAAAA,EAAMc,OACxBC,YAAa,WAAMf,OAAAA,EAAMgB,QACzBC,UAAWpB,EAAKqB,QAAQ,sBACxBC,WAAYtB,EAAKqB,QAAQ,uBACzBE,KAAMvB,EAAKwB,KAAK,QAChBC,MAAOzB,EAAKwB,KAAK,UAErB9B,MAAAA,EAAAA,QAGEgC,EAAQ,CAAC,SAAU,QAAS,WAC5BC,EAAQ,CAAEJ,KAAM,EAAGE,MAAO,GAE1BG,EAAQ,CAAEC,MAAO,CAAC,EAAG,EAAG,EAAG,GAAIC,MAAO,GAE5C,SAASC,IACL/B,EAAK4B,MAAMA,GACXlB,EAAKiB,GAGTK,SAAS3B,iBAAiB,YAAa,SAAoB,GAAR4B,IAAAA,EAATC,EAAAA,QACtCP,EAAMF,MAAQU,KAAKC,IAAIH,EAAEI,WAAY,MACb,WAAtBX,EAAMC,EAAMJ,OAAuBe,QAAQC,IAAI,SAAUZ,EAAMF,SAGrEO,SAAS3B,iBAAiB,QAAS,WAC/BsB,EAAMJ,MAAQI,EAAMJ,KAAK,GAAGG,EAAM/B,OAClC2C,QAAQC,IAAIb,EAAMC,EAAMJ,MAAM,IAAKI,EAAMJ,QAG7CvB,EAAK+B,MAAMA","file":"example.35ce1d4e.js","sourceRoot":"../example","sourcesContent":["/**\n * The 3 vertices of a 2D triangle covering the viewport in NDC coordinates ([-1, 1]).\n *\n * @export\n * @type {array.<array.<number>>}\n */\nexport const vertices = [[-1, -1], [-1, 4], [4, -1]];\n\nexport const count = vertices.length;\nexport const dim = 2;\n\n/**\n * The flat array of the above triangle, to be bound as a WebGL attribute buffer for\n * rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates ([-1, 1]) over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = vertices.flat();\n\nexport default positions;\n","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvarying vec2 uv;\\n\\n// Flips the y-axis to point downwards.\\nconst vec2 flip = vec2(1, -1);\\n\\nvoid main() {\\n    uv = position*flip;\\n    gl_Position = vec4(position, 0, 1);\\n}\\n\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D image;\\n\\nuniform float imageWidth;\\nuniform float imageHeight;\\n\\nuniform float viewWidth;\\nuniform float viewHeight;\\n\\nuniform float mode;\\nuniform float scale;\\n\\nvarying vec2 uv;\\n\\n// Implementations for each dimension.\\n\\nfloat aspect(in float size, in float scale) {\\n    return scale/size;\\n}\\n\\nvec2 aspect(in vec2 size, in vec2 scale) {\\n    return scale/size;\\n}\\n\\nvec3 aspect(in vec3 size, in vec3 scale) {\\n    return scale/size;\\n}\\n\\nvec4 aspect(in vec4 size, in vec4 scale) {\\n    return scale/size;\\n}\\n\\n// These are for `scale` always `float`:\\n\\nvec2 aspect(in vec2 size, in float scale) {\\n    return aspect(size, vec2(scale));\\n}\\n\\nvec3 aspect(in vec3 size, in float scale) {\\n    return aspect(size, vec3(scale));\\n}\\n\\nvec4 aspect(in vec4 size, in float scale) {\\n    return aspect(size, vec4(scale));\\n}\\n\\nvec2 aspectCover(in vec2 size) {\\n    return aspect(size, max(size.x, size.y));\\n}\\n\\nvec3 aspectCover(in vec3 size) {\\n    return aspect(size, max(size.x, max(size.y, size.z)));\\n}\\n\\nvec4 aspectCover(in vec4 size) {\\n    return aspect(size, max(size.x, max(size.y, max(size.z, size.w))));\\n}\\n\\nvec2 aspectContain(in vec2 size) {\\n    return aspect(size, min(size.x, size.y));\\n}\\n\\nvec3 aspectContain(in vec3 size) {\\n    return aspect(size, min(size.x, min(size.y, size.z)));\\n}\\n\\nvec4 aspectContain(in vec4 size) {\\n    return aspect(size, min(size.x, min(size.y, min(size.z, size.w))));\\n}\\n\\nvoid main() {\\n    vec2 imageSize = vec2(imageWidth, imageHeight);\\n    vec2 viewSize = vec2(viewWidth, viewHeight);\\n    vec2 size = imageSize/viewSize;\\n    int m = int(mode);\\n\\n    vec2 st = uv*((m == 0)? aspect(size, scale)\\n            : ((m == 1)? aspectCover(size)\\n            :   aspectContain(size)));\\n\\n    st = (st*vec2(0.5, -0.5))+0.5;\\n\\n    vec4 pixel = texture2D(image, st);\\n    vec2 limit = abs(floor(st));\\n\\n    gl_FragColor = mix(vec4(0, 0, 0, 1), pixel, step(max(limit.x, limit.y), 0.0));\\n}\\n\";","// Any rendering library, but made with `regl` in mind.\nimport getRegl from 'regl';\nimport { positions, count } from '@epok.tech/gl-screen-triangle';\n\nimport imageSrc from './assets/baboon.png';\n\nimport vert from '@epok.tech/gl-screen-triangle/uv-ndc.vert.glsl';\n\nimport frag from './index.frag.glsl';\n\nconst regl = getRegl();\n\nconst img = new Image();\nconst image = regl.texture();\n\nimg.addEventListener('load', () => image({ data: img, flipY: true }));\nimg.src = imageSrc;\n\nconst draw = regl({\n    vert,\n    frag,\n    attributes: { position: positions },\n    uniforms: {\n        image,\n        imageWidth: () => image.width,\n        imageHeight: () => image.height,\n        viewWidth: regl.context('drawingBufferWidth'),\n        viewHeight: regl.context('drawingBufferHeight'),\n        mode: regl.prop('mode'),\n        scale: regl.prop('scale')\n    },\n    count\n});\n\nconst modes = ['aspect', 'cover', 'contain'];\nconst state = { mode: 0, scale: 1 };\n\nconst clear = { color: [0, 0, 0, 0], depth: 1 };\n\nfunction frame() {\n    regl.clear(clear);\n    draw(state);\n}\n\ndocument.addEventListener('mousemove', ({ clientX: x }) => {\n    state.scale = Math.max(x/innerWidth, 0.000001);\n    ((modes[state.mode] === 'aspect') && console.log('scale:', state.scale));\n});\n\ndocument.addEventListener('click', () => {\n    state.mode = (state.mode+1)%modes.length;\n    console.log(modes[state.mode]+':', state.mode);\n});\n\nregl.frame(frame);\n"]}