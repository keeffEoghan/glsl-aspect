{"version":3,"sources":["../node_modules/@epok.tech/gl-screen-triangle/index.js","../node_modules/@epok.tech/gl-screen-triangle/uv-texture.vert.glsl","index.frag.glsl","index.js"],"names":["positions","module","exports","regl","img","Image","image","texture","addEventListener","data","flipY","src","imageSrc","draw","vert","frag","attributes","position","uniforms","imageWidth","width","imageHeight","height","viewWidth","context","viewHeight","mode","prop","scale","count","length","modes","state","clear","color","depth","frame","document","x","clientX","Math","max","innerWidth","console","log"],"mappings":";;;;;AAeeA,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,QAAAA,QAAAA,eAAAA,EANR,IAAMA,EAAY,EACpB,GAAI,GACJ,EAAG,EACJ,GAAI,GAGOA,QAAAA,UAAAA,EAAAA,IAAAA,EAAAA,EAAAA,QAAAA,QAAAA;;;;ACffC,OAAOC,QAAQ;;ACAfD,OAAOC,QAAQ;;ACsDf,aArDA,IAAA,EAAA,EAAA,QAAA,SACA,EAAA,EAAA,QAAA,kCAEA,EAAA,EAAA,QAAA,wBAEA,EAAA,EAAA,QAAA,uDAEA,EAAA,EAAA,QAAA,sBA8CA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GA5CA,IAAMC,GAAO,EAAb,EAAA,WAEMC,EAAM,IAAIC,MACVC,EAAQH,EAAKI,UAEnBH,EAAII,iBAAiB,OAAQ,WAAMF,OAAAA,EAAM,CAAEG,KAAML,EAAKM,OAAO,MAC7DN,EAAIO,IAAMC,EAAV,QAEA,IAAMC,EAAOV,EAAK,CACdW,KAAAA,EADc,QAEdC,KAAAA,EAFc,QAGdC,WAAY,CAAEC,SAAUjB,EAAAA,SACxBkB,SAAU,CACNZ,MAAAA,EACAa,WAAY,WAAMb,OAAAA,EAAMc,OACxBC,YAAa,WAAMf,OAAAA,EAAMgB,QACzBC,UAAWpB,EAAKqB,QAAQ,sBACxBC,WAAYtB,EAAKqB,QAAQ,uBACzBE,KAAMvB,EAAKwB,KAAK,QAChBC,MAAOzB,EAAKwB,KAAK,UAErBE,MAAO7B,EAAU8B,QAAAA,OAAO,IAGtBC,EAAQ,CAAC,SAAU,QAAS,WAC5BC,EAAQ,CAAEN,KAAM,EAAGE,MAAO,GAE1BK,EAAQ,CAAEC,MAAO,CAAC,EAAG,EAAG,EAAG,GAAIC,MAAO,GAE5C,SAASC,IACLjC,EAAK8B,MAAMA,GACXpB,EAAKmB,GAGTK,SAAS7B,iBAAiB,YAAa,SAAoB,GAAR8B,IAAAA,EAATC,EAAAA,QACtCP,EAAMJ,MAAQY,KAAKC,IAAIH,EAAEI,WAAY,MACrCC,QAAQC,IAAI,SAAUZ,EAAMJ,SAGhCS,SAAS7B,iBAAiB,QAAS,WAC/BwB,EAAMN,MAAQM,EAAMN,KAAK,GAAGK,EAAMD,OAClCa,QAAQC,IAAIb,EAAMC,EAAMN,MAAM,IAAKM,EAAMN,QAG7CvB,EAAKiC,MAAMA","file":"example.04054372.js","sourceRoot":"../example","sourcesContent":["/**\n * The flat array (3 vertices of a 2D triangle) to be bound as a WebGL attribute\n * buffer for rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates in the range [-1, 1] over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = [\n    -1, -1,\n    -1, 4,\n    4, -1\n];\n\nexport default positions;\n","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvarying vec2 uv;\\n\\n// Translation for UV NDC to texture coordinates.\\nconst vec2 offset = vec2(0.5);\\n\\nvoid main() {\\n    uv = (position*0.5)+offset;\\n    gl_Position = vec4(position, 0, 1);\\n}\\n\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D image;\\n\\nuniform float imageWidth;\\nuniform float imageHeight;\\n\\nuniform float viewWidth;\\nuniform float viewHeight;\\n\\nuniform float mode;\\nuniform float scale;\\n\\nvarying vec2 uv;\\n\\n// Implementations for each dimension.\\n\\nfloat aspect(in float size, in float scale) {\\n    return scale/size;\\n}\\n\\nvec2 aspect(in vec2 size, in vec2 scale) {\\n    return scale/size;\\n}\\n\\nvec3 aspect(in vec3 size, in vec3 scale) {\\n    return scale/size;\\n}\\n\\nvec4 aspect(in vec4 size, in vec4 scale) {\\n    return scale/size;\\n}\\n\\n// These are for `scale` always `float`:\\n\\nvec2 aspect(in vec2 size, in float scale) {\\n    return aspect(size, vec2(scale));\\n}\\n\\nvec3 aspect(in vec3 size, in float scale) {\\n    return aspect(size, vec3(scale));\\n}\\n\\nvec4 aspect(in vec4 size, in float scale) {\\n    return aspect(size, vec4(scale));\\n}\\n\\nvec2 aspectCover(in vec2 size) {\\n    return aspect(size, max(size.x, size.y));\\n}\\n\\nvec3 aspectCover(in vec3 size) {\\n    return aspect(size, max(size.x, max(size.y, size.z)));\\n}\\n\\nvec4 aspectCover(in vec4 size) {\\n    return aspect(size, max(size.x, max(size.y, max(size.z, size.w))));\\n}\\n\\nvec2 aspectContain(in vec2 size) {\\n    return aspect(size, min(size.x, size.y));\\n}\\n\\nvec3 aspectContain(in vec3 size) {\\n    return aspect(size, min(size.x, min(size.y, size.z)));\\n}\\n\\nvec4 aspectContain(in vec4 size) {\\n    return aspect(size, min(size.x, min(size.y, min(size.z, size.w))));\\n}\\n\\nvoid main() {\\n    vec2 imageSize = vec2(imageWidth, imageHeight);\\n    vec2 viewSize = vec2(viewWidth, viewHeight);\\n    vec2 size = imageSize/viewSize;\\n    int m = int(mode);\\n\\n    gl_FragColor = texture2D(image,\\n        uv*((m == 0)? aspect(size, scale)\\n            : ((m == 1)? aspectCover(size)\\n            :   aspectContain(size))));\\n}\\n\";","// Any rendering library, but made with `regl` in mind.\nimport getRegl from 'regl';\nimport positions from '@epok.tech/gl-screen-triangle';\n\nimport imageSrc from './assets/baboon.png';\n\nimport vert from '@epok.tech/gl-screen-triangle/uv-texture.vert.glsl';\n\nimport frag from './index.frag.glsl';\n\nconst regl = getRegl();\n\nconst img = new Image();\nconst image = regl.texture();\n\nimg.addEventListener('load', () => image({ data: img, flipY: true }));\nimg.src = imageSrc;\n\nconst draw = regl({\n    vert,\n    frag,\n    attributes: { position: positions },\n    uniforms: {\n        image,\n        imageWidth: () => image.width,\n        imageHeight: () => image.height,\n        viewWidth: regl.context('drawingBufferWidth'),\n        viewHeight: regl.context('drawingBufferHeight'),\n        mode: regl.prop('mode'),\n        scale: regl.prop('scale')\n    },\n    count: positions.length/2\n});\n\nconst modes = ['aspect', 'cover', 'contain'];\nconst state = { mode: 0, scale: 1 };\n\nconst clear = { color: [0, 0, 0, 0], depth: 1 };\n\nfunction frame() {\n    regl.clear(clear);\n    draw(state);\n}\n\ndocument.addEventListener('mousemove', ({ clientX: x }) => {\n    state.scale = Math.max(x/innerWidth, 0.000001);\n    console.log('scale:', state.scale);\n});\n\ndocument.addEventListener('click', () => {\n    state.mode = (state.mode+1)%modes.length;\n    console.log(modes[state.mode]+':', state.mode);\n});\n\nregl.frame(frame);\n"]}